# ConfigMap and Secret Example
#
# This example demonstrates mixing ConfigMap and Secret as value sources,
# showing when to use each type and how they work together.
#
# What this example shows:
# - Using ConfigMap for non-sensitive configuration
# - Using Secret for sensitive data (credentials, API keys)
# - How to reference both in the same WerfBundle
# - Proper Secret data encoding (base64)
#
# Best practices:
# - ConfigMap: Use for non-sensitive config (URLs, feature flags, resource limits)
# - Secret: Use for credentials, tokens, API keys, certificates
# - Both use the same 'values.yaml' key structure
# - Secrets are base64-encoded by Kubernetes automatically when you create them
#
# To apply this example:
# 1. Update the registry URL to point to your actual bundle
# 2. Ensure the 'production' namespace exists
# 3. Create a ServiceAccount with appropriate RBAC (see docs/job-rbac.md)
# 4. Apply: kubectl apply -f values-configmap-and-secret.yaml

---
# ConfigMap for non-sensitive application configuration
# This data is visible to anyone who can read ConfigMaps in the namespace
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: k8s-werf-operator-go-system
data:
  values.yaml: |
    app:
      name: data-processor
      replicas: 3
      logLevel: info

    # Non-sensitive configuration
    services:
      apiUrl: https://api.example.com
      timeout: 30s
      retryAttempts: 3

    features:
      enableCache: true
      enableMetrics: true

---
# Secret for sensitive credentials
# This data is base64-encoded and should be protected with RBAC
# IMPORTANT: The values.yaml content below is base64-encoded
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
  namespace: k8s-werf-operator-go-system
type: Opaque
data:
  # The 'values.yaml' key must contain base64-encoded YAML
  # Original YAML being encoded:
  #   database:
  #     host: postgres.production.svc.cluster.local
  #     port: 5432
  #     username: app_user
  #     password: super_secret_password
  #     sslMode: require
  #
  # To generate this encoding, use:
  # echo 'database:
  #   host: postgres.production.svc.cluster.local
  #   port: 5432
  #   username: app_user
  #   password: super_secret_password
  #   sslMode: require' | base64 -w 0
  #
  values.yaml: ZGF0YWJhc2U6CiAgaG9zdDogcG9zdGdyZXMucHJvZHVjdGlvbi5zdmMuY2x1c3Rlci5sb2NhbAogIHBvcnQ6IDU0MzIKICB1c2VybmFtZTogYXBwX3VzZXIKICBwYXNzd29yZDogc3VwZXJfc2VjcmV0X3Bhc3N3b3JkCiAgc3NsTW9kZTogcmVxdWlyZQo=

---
# WerfBundle using both ConfigMap and Secret
apiVersion: werf.io/v1alpha1
kind: WerfBundle
metadata:
  name: data-processor
  namespace: k8s-werf-operator-go-system
spec:
  registry:
    url: ghcr.io/org/data-processor-bundle
    pollInterval: 15m

  converge:
    targetNamespace: production
    serviceAccountName: werf-converge
    resourceLimits:
      cpu: "2"
      memory: "2Gi"

    # Mix ConfigMap and Secret sources
    # Both are merged together - order still matters for overlapping keys
    valuesFrom:
      # Non-sensitive config from ConfigMap
      - configMapRef:
          name: app-config

      # Sensitive credentials from Secret
      - secretRef:
          name: database-credentials

    # The operator will:
    # 1. Read app-config ConfigMap, extract values.yaml
    # 2. Read database-credentials Secret, base64-decode data, extract values.yaml
    # 3. Merge both YAML documents
    # 4. Flatten to dot notation
    # 5. Pass as --set flags to werf converge
    #
    # Final flags will include:
    # --set app.name=data-processor
    # --set app.replicas=3
    # --set services.apiUrl=https://api.example.com
    # --set database.host=postgres.production.svc.cluster.local
    # --set database.username=app_user
    # --set database.password=super_secret_password
    # ... and so on
